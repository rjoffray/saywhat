{"ts":1359863203565,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Connect - logger\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Log buffer.\n */\n\nvar buf = [];\n\n/**\n * Default log buffer duration.\n */\n\nvar defaultBufferDuration = 1000;\n\n/**\n * Log requests with the given `options` or a `format` string.\n *\n * Options:\n *\n *   - `format`  Format string, see below for tokens\n *   - `stream`  Output stream, defaults to _stdout_\n *   - `buffer`  Buffer duration, defaults to 1000ms when _true_\n *   - `immediate`  Write log line on request instead of response (for response times)\n *\n * Tokens:\n *\n *   - `:req[header]` ex: `:req[Accept]`\n *   - `:res[header]` ex: `:res[Content-Length]`\n *   - `:http-version`\n *   - `:response-time`\n *   - `:remote-addr`\n *   - `:date`\n *   - `:method`\n *   - `:url`\n *   - `:referrer`\n *   - `:user-agent`\n *   - `:status`\n *\n * Formats:\n *\n *   Pre-defined formats that ship with connect:\n *\n *    - `default` ':remote-addr - - [:date] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"'\n *    - `short` ':remote-addr - :method :url HTTP/:http-version :status :res[content-length] - :response-time ms'\n *    - `tiny`  ':method :url :status :res[content-length] - :response-time ms'\n *    - `dev` concise output colored by response status for development use\n *\n * Examples:\n *\n *      connect.logger() // default\n *      connect.logger('short')\n *      connect.logger('tiny')\n *      connect.logger('dev')\n *      connect.logger(':method :url - :referrer')\n *      connect.logger(':req[content-type] -> :res[content-type]')\n *      connect.logger(function(req, res){ return 'some format string' })\n *\n * Defining Tokens:\n *\n *   To define a token, simply invoke `connect.logger.token()` with the\n *   name and a callback function. The value returned is then available\n *   as \":type\" in this case.\n *\n *      connect.logger.token('type', function(req, res){ return req.headers['content-type']; })\n *\n * Defining Formats:\n *\n *   All default formats are defined this way, however it's public API as well:\n *\n *       connect.logger.format('name', 'string or function')\n *\n * @param {String|Function|Object} format or options\n * @return {Function}\n * @api public\n */\n\nexports = module.exports = function logger(options) {\n  if ('object' == typeof options) {\n    options = options || {};\n  } else if (options) {\n    options = { format: options };\n  } else {\n    options = {};\n  }\n\n  // output on request instead of response\n  var immediate = options.immediate;\n\n  // format name\n  var fmt = exports[options.format] || options.format || exports.default;\n\n  // compile format\n  if ('function' != typeof fmt) fmt = compile(fmt);\n\n  // options\n  var stream = options.stream || process.stdout\n    , buffer = options.buffer;\n\n  // buffering support\n  if (buffer) {\n    var realStream = stream\n      , interval = 'number' == typeof buffer\n        ? buffer\n        : defaultBufferDuration;\n\n    // flush interval\n    setInterval(function(){\n      if (buf.length) {\n        realStream.write(buf.join(''), 'ascii');\n        buf.length = 0;\n      }\n    }, interval); \n\n    // swap the stream\n    stream = {\n      write: function(str){\n        buf.push(str);\n      }\n    };\n  }\n\n  return function logger(req, res, next) {\n    req._startTime = new Date;\n\n    // mount safety\n    if (req._logging) return next();\n\n    // flag as logging\n    req._logging = true;\n\n    // immediate\n    if (immediate) {\n      var line = fmt(exports, req, res);\n      if (null == line) return;\n      stream.write(line + '\\n', 'ascii');\n    } else {\n      // proxy end to output loggging\n      var end = res.end;\n      res.end = function(chunk, encoding){\n        res.end = end;\n        res.end(chunk, encoding);\n        var line = fmt(exports, req, res);\n        if (null == line) return;\n        stream.write(line + '\\n', 'ascii');\n      };\n    }\n\n\n    next();\n  };\n};\n\n/**\n * Compile `fmt` into a function.\n *\n * @param {String} fmt\n * @return {Function}\n * @api private\n */\n\nfunction compile(fmt) {\n  fmt = fmt.replace(/\"/g, '\\\\\"');\n  var js = '  return \"' + fmt.replace(/:([-\\w]{2,})(?:\\[([^\\]]+)\\])?/g, function(_, name, arg){\n    return '\"\\n    + (tokens[\"' + name + '\"](req, res, \"' + arg + '\") || \"-\") + \"';\n  }) + '\";'\n  return new Function('tokens, req, res', js);\n};\n\n/**\n * Define a token function with the given `name`,\n * and callback `fn(req, res)`.\n *\n * @param {String} name\n * @param {Function} fn\n * @return {Object} exports for chaining\n * @api public\n */\n\nexports.token = function(name, fn) {\n  exports[name] = fn;\n  return this;\n};\n\n/**\n * Define a `fmt` with the given `name`.\n *\n * @param {String} name\n * @param {String|Function} fmt\n * @return {Object} exports for chaining\n * @api public\n */\n\nexports.format = function(name, str){\n  exports[name] = str;\n  return this;\n};\n\n// default format\n\nexports.format('default', ':remote-addr - - [:date] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"');\n\n// short format\n\nexports.format('short', ':remote-addr - :method :url HTTP/:http-version :status :res[content-length] - :response-time ms');\n\n// tiny format\n\nexports.format('tiny', ':method :url :status :res[content-length] - :response-time ms');\n\n// dev (colored)\n\nexports.format('dev', function(tokens, req, res){\n  var status = res.statusCode\n    , color = 32;\n\n  if (status >= 500) color = 31\n  else if (status >= 400) color = 33\n  else if (status >= 300) color = 36;\n\n  return '\\033[90m' + req.method\n    + ' ' + req.originalUrl + ' '\n    + '\\033[' + color + 'm' + res.statusCode\n    + ' \\033[90m'\n    + (new Date - req._startTime)\n    + 'ms\\033[0m';\n});\n\n// request url\n\nexports.token('url', function(req){\n  return req.originalUrl;\n});\n\n// request method\n\nexports.token('method', function(req){\n  return req.method;\n});\n\n// response time in milliseconds\n\nexports.token('response-time', function(req){\n  return new Date - req._startTime;\n});\n\n// UTC date\n\nexports.token('date', function(){\n  return new Date().toUTCString();\n});\n\n// response status code\n\nexports.token('status', function(req, res){\n  return res.statusCode;\n});\n\n// normalized referrer\n\nexports.token('referrer', function(req){\n  return req.headers['referer'] || req.headers['referrer'];\n});\n\n// remote address\n\nexports.token('remote-addr', function(req){\n  return req.socket && (req.socket.remoteAddress || (req.socket.socket && req.socket.socket.remoteAddress));\n});\n\n// HTTP version\n\nexports.token('http-version', function(req){\n  return req.httpVersionMajor + '.' + req.httpVersionMinor;\n});\n\n// UA string\n\nexports.token('user-agent', function(req){\n  return req.headers['user-agent'];\n});\n\n// request header\n\nexports.token('req', function(req, res, field){\n  return req.headers[field.toLowerCase()];\n});\n\n// response header\n\nexports.token('res', function(req, res, field){\n  return (res._headers || {})[field.toLowerCase()];\n});\n\n"]],"start1":0,"start2":0,"length1":0,"length2":6902}]],"length":6902}
