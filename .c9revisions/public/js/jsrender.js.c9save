{"ts":1359668902988,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*! JsRender v1.0pre: http://github.com/BorisMoore/jsrender */\n/*\n* Optimized version of jQuery Templates, for rendering to string.\n* Does not require jQuery, or HTML DOM\n* Integrates with JsViews (http://github.com/BorisMoore/jsviews)\n* Copyright 2012, Boris Moore\n* Released under the MIT License.\n*/\n// informal pre beta commit counter: 21\n\n(function(global, jQuery, undefined) {\n    // global is the this object, which is window when running in the usual browser environment.\n\n\tif (jQuery && jQuery.views || global.jsviews) return; // JsRender is already loaded\n\n\t//========================== Top-level vars ==========================\n\n\tvar versionNumber = \"v1.0pre\",\n\n\t\t$, rTag, rTmplString, $extend,\n//\t\tcompiledTmplsCache = {},\n\t\tdelimOpenChar0 = \"{\", delimOpenChar1 = \"{\", delimCloseChar0 = \"}\", delimCloseChar1 = \"}\", deferChar = \"!\",\n\t\t$viewsSub = {},\n\t\tFALSE = false, TRUE = true,\n\n\t\trPath = /^(?:null|true|false|\\d[\\d.]*|([\\w$]+|~([\\w$]+)|#(view|([\\w$]+))?)([\\w$.]*?)(?:[.[]([\\w$]+)\\]?)?|(['\"]).*\\8)$/g,\n\t\t//                               nil   object   helper    view  viewProperty pathTokens   leafToken     string\n\n\t\trParams = /(\\()(?=|\\s*\\()|(?:([([])\\s*)?(?:([#~]?[\\w$.]+)?\\s*((\\+\\+|--)|\\+|-|&&|\\|\\||===|!==|==|!=|<=|>=|[<>%*!:?\\/]|(=))\\s*|([#~]?[\\w$.]+)([([])?)|(,\\s*)|(\\(?)\\\\?(?:(')|(\"))|(?:\\s*([)\\]])([([]?))|(\\s+)/g,\n\t\t//          lftPrn        lftPrn2                path    operator err                                                eq         path2       prn    comma   lftPrn2   apos quot        rtPrn   prn2   space\n\t\t// (left paren? followed by (path? followed by operator) or (path followed by paren?)) or comma or apos or quot or right paren or space\n\n\t\trNewLine = /\\r?\\n/g,\n\t\trUnescapeQuotes = /\\\\(['\"])/g,\n\t\trEscapeQuotes = /\\\\?(['\"])/g,\n\t\trBuildHash = /\\x08(~)?([^\\x08]+)\\x08/g,\n\n\t\tautoTmplName = 0,\n\t\tescapeMapForHtml = {\n\t\t\t\"&\": \"&amp;\",\n\t\t\t\"<\": \"&lt;\",\n\t\t\t\">\": \"&gt;\"\n\t\t},\n\t\ttmplAttr = \"data-jsv-tmpl\",\n\t\tfnDeclStr = \"var j=j||\" + (jQuery ? \"jQuery.\" : \"js\") + \"views,\",\n\t\thtmlSpecialChar = /[\\x00\"&'<>]/g,\n\t\tslice = Array.prototype.slice,\n\n\t\t$render = {},\n\n\t\t// jsviews object ($.views if jQuery is loaded)\n\t\t$views = {\n\t\t\tjsviews: versionNumber,\n\t\t\tsub: $viewsSub, // subscription, e.g. JsViews integration\n\t\t\tdebugMode: TRUE,\n\t\t\trender: $render,\n\t\t\ttemplates: $templates,\n\t\t\ttags: $viewsTags,\n\t\t\thelpers: $viewsHelpers,\n\t\t\tconverters: $viewsConverters,\n\t\t\tdelimiters: $viewsDelimiters,\n\t\t\tView: View,\n\t\t\t_convert: convert,\n\t\t\t_err: function(e) {\n\t\t\t\treturn $views.debugMode ? (\"Error: \" + (e.message || e)) + \". \" : '';\n\t\t\t},\n\t\t\t_tmplFn: tmplFn,\n\t\t\t_tag: renderTag,\n\t\t\terror: error,\n\t\t\tError: JsViewsError\n\t\t};\n\n\t\tfunction JsViewsError(message) { // Error exception type for JsViews/JsRender\n\t\t\tthis.name = \"JsRender Error\",\n\t\t\tthis.message = message || \"JsRender error\"\n\t\t}\n\n\t\t(JsViewsError.prototype = new Error()).constructor = JsViewsError;\n\n\t//========================== Top-level functions ==========================\n\n\t//===================\n\t// jsviews.delimiters\n\t//===================\n\n\tfunction $viewsDelimiters(openChars, closeChars, defer) {\n\t\t// Set the tag opening and closing delimiters. Default is \"{{\" and \"}}\"\n\t\t// openChar, closeChars: opening and closing strings, each with two characters\n\n\t\tif (!$views.rTag || arguments.length) {\n\t\t\tdelimOpenChar0 = openChars ? \"\\\\\" + openChars.charAt(0) : delimOpenChar0; // Escape the characters - since they could be regex special characters\n\t\t\tdelimOpenChar1 = openChars ? \"\\\\\" + openChars.charAt(1) : delimOpenChar1;\n\t\t\tdelimCloseChar0 = closeChars ? \"\\\\\" + closeChars.charAt(0) : delimCloseChar0;\n\t\t\tdelimCloseChar1 = closeChars ? \"\\\\\" + closeChars.charAt(0) : delimCloseChar1;\n\t\t\tdefer = defer ? \"\\\\\" + defer : deferChar;\n\n\t\t\t// Build regex with new delimiters\n\t\t\t$views.rTag = rTag // make rTag available to JsViews (or other components) for parsing binding expressions\n\t\t\t\t//          tag    (followed by / space or })   or cvtr+colon or html or code\n\t\t\t\t= \"(\\\\w*\" + defer + \")?(?:(?:(\\\\w+(?=[\\\\/\\\\s\" + delimCloseChar0 + \"]))|(?:(\\\\w+)?(:)|(>)|(\\\\*)))\"\n\t\t\t\t//     params\n\t\t\t\t+ \"\\\\s*((?:[^\" + delimCloseChar0 + \"]|\" + delimCloseChar0 + \"(?!\" + delimCloseChar1 + \"))*?)\";\n\n\t\t\t//                                         slash or closeBlock           }}\n\t\t\trTag = new RegExp(delimOpenChar0 + delimOpenChar1 + rTag + \"(\\\\/)?|(?:\\\\/(\\\\w+)))\" + delimCloseChar0 + delimCloseChar1, \"g\");\n\n\t\t\t// Default rTag:    tag      converter colon html code     params            slash   closeBlock\n\t\t\t//    /{{(?:(?:(\\w+(?=[\\/\\s}]))|(?:(\\w+)?(:)|(>)|(\\*)))\\s*((?:[^}]|}(?!}))*?)(\\/)?|(?:\\/(\\w+)))}}\n\n\t\t\trTmplString = new RegExp(\"<.*>|([^\\\\\\\\]|^)[{}]|\" + delimOpenChar0 + delimOpenChar1 + \".*\" + delimCloseChar0 + delimCloseChar1);\n\t\t\t// rTmplString looks for html tags or { or } char not preceeded by \\\\, or JsRender tags {{xxx}}. Each of these strings are considered NOT to be jQuery selectors\n\t\t}\n\t\treturn [delimOpenChar0, delimOpenChar1, delimCloseChar0, delimCloseChar1, deferChar];\n\t}\n\n\t//=================\n\t// View._hlp\n\t//=================\n\n\tfunction getHelper(helper) {\n\t\t// Helper method called as view._hlp() from compiled template, for helper functions or template parameters ~foo\n\t\tvar view = this,\n\t\t\ttmplHelpers = view.tmpl.helpers || {};\n\n\t\thelper = (\n\t\t\tview.dynCtx && view.dynCtx[helper] !== undefined\n\t\t\t\t? view.dynCtx\n\t\t\t\t: view.ctx[helper] !== undefined\n\t\t\t\t\t? view.ctx\n\t\t\t\t\t: tmplHelpers[helper] !== undefined\n\t\t\t\t\t\t? tmplHelpers\n\t\t\t\t\t\t: $viewsHelpers[helper] !== undefined\n\t\t\t\t\t\t\t? $viewsHelpers\n\t\t\t\t\t\t\t: {}\n\t\t)[helper];\n\t\treturn typeof helper !== \"function\" ? helper : function() {\n\t\t\treturn helper.apply(view, arguments);\n\t\t};\n\t}\n\n\t//=================\n\t// jsviews._convert\n\t//=================\n\n\tfunction convert(converter, view, self, text) {\n\t\t// self is template object or link object\n\t\tvar linkContext = !self.markup && self || undefined,\n\t\t\ttmplConverter = view.tmpl.converters;\n\t\ttmplConverter = tmplConverter && tmplConverter[converter] || $viewsConverters[converter];\n\t\treturn tmplConverter ? tmplConverter.call(view, text, linkContext) : (error(\"Unknown converter: {{\"+ converter + \":\"), text);\n\t}\n\n\t//=================\n\t// jsviews._tag\n\t//=================\n\n\tfunction renderTag(tag, parentView, self, content, tagInstance) {\n\t\t// Called from within compiled template function, to render a nested tag\n\t\t// Returns the rendered tag\n\t\tvar ret,\n\t\t\tlinkCtx = !self.markup && self,  // self is either a template object (if rendering a tag) or a linkCtx object (if linking using a link tag)\n\t\t\tparentTmpl = linkCtx ? linkCtx.view.tmpl : self,\n\t\t\ttmplTags = parentTmpl.tags,\n\t\t\tnestedTemplates = parentTmpl.templates,\n\t\t\tprops = tagInstance.props = tagInstance.props || {},\n\t\t\ttmpl = props.tmpl,\n\t\t\targs = arguments.length > 5 ? slice.call(arguments, 5) : [],\n\t\t\ttagObject = tmplTags && tmplTags[tag] || $viewsTags[tag];\n\n\t\tif (!tagObject) {\n\t\t\terror(\"Unknown tag: {{\"+ tag + \"}}\");\n\t\t\treturn \"\";\n\t\t}\n\t\t// Set the tmpl property to the content of the block tag, unless set as an override property on the tag\n\t\tcontent = content && parentTmpl.tmpls[content - 1];\n\t\ttmpl = tmpl || content || tagObject.template || undefined;\n\t\ttagInstance.view = parentView;\n\t\ttmpl = tagInstance.tmpl =\n\t\t\t\"\" + tmpl === tmpl // if a string\n\t\t\t\t? nestedTemplates && nestedTemplates[tmpl] || $templates[tmpl] || $templates(tmpl)\n\t\t\t\t: tmpl;\n\n\t\ttagInstance.attr =\n\t\t\t// Setting attr on tagInstance so renderContent knows whether to include template annotations.\n\t\t\tself.attr =\n\t\t\t\t// Setting attr on self.fn to ensure outputting to the correct target attribute.\n\t\t\t\tself.attr || tagObject.attr;\n\n\t\ttagInstance.tagName = tag;\n\t\ttagInstance.renderContent = renderContent;\n\t\tif (linkCtx) {\n\t\t\tlinkCtx.tagCtx = {\n\t\t\t\targs: args,\n\t\t\t\tprops: props,\n\t\t\t\tpath: tagInstance.path,\n\t\t\t\ttag: tagObject\n\t\t\t};\n\t\t}\n\t\t// If render function is declared, call it. If the return result is undefined, return \"\", or, if a template (or content) is provide, return the rendered template (using the first parameter as data);\n\t\tif (tagObject.render) {\n\t\t\tret = tagObject.render.apply(tagInstance, args);\n\t\t}\n\t\treturn ret || (ret == undefined\n\t\t\t? (tmpl\n\t\t\t\t? tagInstance.renderContent(args[0], undefined, parentView)\n\t\t\t\t: \"\")\n\t\t\t: ret.toString()); // (If ret is the value 0 or false, will render to string)\n\t}\n\n\t//=================\n\t// View constructor\n\t//=================\n\n\tfunction View(context, path, parentView, data, template, key, onRender, isArray) {\n\t\t// Constructor for view object in view hierarchy. (Augmented by JsViews if JsViews is loaded)\n\t\tvar views,\n\t\t\tself = {\n\t\t\t\tdata: data,\n\t\t\t\ttmpl: template,\n\t\t\t\tviews: isArray ? [] : {},\n\t\t\t\tparent: parentView,\n\t\t\t\tctx: context,\n\t\t\t\t// If the data is an array, this is an 'Array View' with a views array for each child 'Instance View'\n\t\t\t\t// If the data is not an array, this is an 'Instance View' with a views 'map' object for any child nested views\n\t\t\t\t// _useKey is non zero if is not an 'Array View' (owning a data array). Uuse this as next key for adding to child views map\n\t\t\t\tpath: path,\n\t\t\t\t_useKey: isArray ? 0 : 1,\n\t\t\t\t_onRender: onRender,\n\t\t\t\t_hlp: getHelper,\n\t\t\t\trenderLink: function(index) {\n\t\t\t\t\tvar linkTmpl = this.tmpl.tmpls[index];\n\t\t\t\t\treturn linkTmpl.render(data, context, this);\n\t\t\t\t}\n\t\t\t};\n\n\t\tif (parentView) {\n\t\t\tviews = parentView.views;\n\t\t\tif (parentView._useKey) {\n\t\t\t\t// Parent is an 'Instance View'. Add this view to its views object\n\t\t\t\t// self.key = is the key in the parent view map\n\t\t\t\tviews[self.key = \"_\" + parentView._useKey++] = self;\n\t\t\t\t// self.index = is index of the parent\n\t\t\t\tself.index = parentView.index;\n\t\t\t} else {\n\t\t\t\t// Parent is an 'Array View'. Add this view to its views array\n\t\t\t\tviews.splice(\n\t\t\t\t// self.key = self.index - the index in the parent view array\n\t\t\t\tself.key = self.index = key !== undefined\n\t\t\t\t\t? key\n\t\t\t\t\t: views.length,\n\t\t\t\t0, self);\n\t\t\t}\n\t\t}\n\t\treturn self;\n\t}\n\n\t//=================\n\t// Registration\n\t//=================\n\n\tfunction addToStore(self, store, name, item, process) {\n\t\t// Add item to named store such as templates, helpers, converters...\n\t\tvar key, onStore;\n\t\tif (name && typeof name === \"object\" && !name.nodeType) {\n\t\t\t// If name is a map, iterate over map and call store for key\n\t\t\tfor (key in name) {\n\t\t\t\tstore(key, name[key]);\n\t\t\t}\n\t\t\treturn self;\n\t\t}\n\t\tif (item === undefined) {\n\t\t\titem = name;\n\t\t\tname = undefined;\n\t\t}\n\t\tif (onStore = $viewsSub.onBeforeStoreItem) {\n\t\t\t// e.g. provide an external compiler or preprocess the item.\n\t\t\tprocess = onStore(store, name, item, process) || process;\n\t\t}\n\t\tif (!name) {\n\t\t\titem = process ? process(item) : item\n\t\t} else if (\"\" + name === name) { // name must be a string\n\t\t\tif (item === null) {\n\t\t\t\t// If item is null, delete this entry\n\t\t\t\tdelete store[name];\n\t\t\t} else {\n\t\t\t\tstore[name] = process ? (item = process(item, name)) : item;\n\t\t\t}\n\t\t}\n\t\tif (onStore = $viewsSub.onStoreItem) {\n\t\t\t// e.g. JsViews integration\n\t\t\tonStore(store, name, item, process);\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction compileTag(item, name) {\n\t\titem = typeof item === \"function\" ? { render: item } : item;\n\t\titem.name = name;\n\t\titem.is = \"tag\";\n\t\treturn item;\n\t}\n\n\tfunction $templates(name, tmpl) {\n\t\t// Register templates\n\t\t// Setter: Use $.templates( name, tmpl ) or $.templates({ name: tmpl, ... }) to add additional templates to the registered templates collection.\n\t\t// Getter: Use var tmpl = $.templates( name ) or $.templates[name] or $.templates.name to return the object for the registered template.\n\t\t// Remove: Use $.templates( name, null ) to remove a registered template from $.templates.\n\t\treturn addToStore(this, $templates, name, tmpl, compile);\n\t}\n\n\tfunction $viewsTags(name, tag) {\n\t\t// Register template tags\n\t\t// Setter: Use $.view.tags( name, tag ) or $.view.tags({ name: tag, ... }) to add additional tags to the registered tags collection.\n\t\t// Getter: Use var tag = $.views.tags( name ) or $.views.tags[name] or $.views.tags.name to return the object for the registered tag.\n\t\t// Remove: Use $.view.tags( name, null ) to remove a registered tag from $.view.tags.\n\n\t\t// When registering for {{foo a b c==d e=f}}, tag should corresponnd to a function with the signature:\n\t\t// function(a,b). The 'this' pointer will be a hash with properties c and e.\n\t\treturn addToStore(this, $viewsTags, name, tag, compileTag);\n\t}\n\n\tfunction $viewsHelpers(name, helperFn) {\n\t\t// Register helper functions for use in templates (or in data-link expressions if JsViews is loaded)\n\t\t// Setter: Use $.view.helpers( name, helperFn ) or $.view.helpers({ name: helperFn, ... }) to add additional helpers to the registered helpers collection.\n\t\t// Getter: Use var helperFn = $.views.helpers( name ) or $.views.helpers[name] or $.views.helpers.name to return the function.\n\t\t// Remove: Use $.view.helpers( name, null ) to remove a registered helper function from $.view.helpers.\n\t\t// Within a template, access the helper using the syntax: {{... ~myHelper(...) ...}}.\n\t\treturn addToStore(this, $viewsHelpers, name, helperFn);\n\t}\n\n\tfunction $viewsConverters(name, converterFn) {\n\t\t// Register converter functions for use in templates (or in data-link expressions if JsViews is loaded)\n\t\t// Setter: Use $.view.converters( name, converterFn ) or $.view.converters({ name: converterFn, ... }) to add additional converters to the registered converters collection.\n\t\t// Getter: Use var converterFn = $.views.converters( name ) or $.views.converters[name] or $.views.converters.name to return the converter function.\n\t\t// Remove: Use $.view.converters( name, null ) to remove a registered converter from $.view.converters.\n\t\t// Within a template, access the converter using the syntax: {{myConverter:...}}.\n\t\treturn addToStore(this, $viewsConverters, name, converterFn);\n\t}\n\n\t//=================\n\t// renderContent\n\t//=================\n\n\tfunction renderContent(data, context, parentView, key, isLayout, path, onRender) {\n\t\t// Render template against data as a tree of subviews (nested template), or as a string (top-level template).\n\t\tvar i, l, dataItem, newView, itemResult, parentContext, tmpl, props, swapContent, mergedCtx, dynCtx, hasContext,\n\t\t\tself = this,\n\t\t\tresult = \"\";\n\n\t\tif (key === TRUE) {\n\t\t\tswapContent = TRUE;\n\t\t\tkey = 0;\n\t\t}\n\t\tif (self.tagName) {\n\t\t\t// This is a call from renderTag\n\t\t\ttmpl = self.tmpl;\n\t\t\tif (context || self.ctx) {\n\t\t\t\t// We need to create an augmented context for the view(s) we are about to render\n\t\t\t\tmergedCtx = {};\n\t\t\t\tif (self.ctx) {\n\t\t\t\t\t// self.ctx is an object with the contextual template parameters on the tag, such as ~foo: {{tag ~foo=expression...}}\n\t\t\t\t\t$extend(mergedCtx, self.ctx);\n\t\t\t\t}\n\t\t\t\tif (context) {\n\t\t\t\t\t// This is a context object passed programmatically from the tag function\n\t\t\t\t\t$extend(mergedCtx, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontext = mergedCtx;\n\t\t\tprops = self.props;\n\t\t\tif ( props && props.link === FALSE ) {\n\t\t\t\t// link=false setting on block tag\n\t\t\t\t// We will override inherited value of link by the explicit setting link=false taken from props\n\t\t\t\t// The child views of an unlinked view are also unlinked. So setting child back to true will not have any effect.\n\t\t\t\tcontext =  context || {};\n\t\t\t\tcontext.link = FALSE;\n\t\t\t}\n\t\t\tparentView = parentView || self.view;\n\t\t\tpath = path || self.path;\n\t\t\tkey = key || self.key;\n//\t\t\tonRender = self.attr === \"html\" && parentView && parentView._onRender;\n\t\t\tonRender = parentView && parentView._onRender;\n\t\t} else {\n\t\t\ttmpl = self.jquery && (self[0] || error('Unknown template: \"' + self.selector + '\"')) // This is a call from $(selector).render\n\t\t\t\t|| self;\n\t\t\tonRender = onRender || parentView && parentView._onRender;\n\t\t}\n\t\tif (tmpl) {\n\t\t\tif (parentView) {\n\t\t\t\tparentContext = parentView.ctx;\n\t\t\t\tdynCtx = parentView.dynCtx;\n\t\t\t\tif (data === parentView) {\n\t\t\t\t\t// Inherit the data from the parent view.\n\t\t\t\t\t// This may be the contents of an {{if}} block\n\t\t\t\t\t// Set isLayout = true so we don't iterate the if block if the data is an array.\n\t\t\t\t\tdata = parentView.data;\n\t\t\t\t\tisLayout = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparentContext = $viewsHelpers;\n\t\t\t}\n\n\t\t\t// Set additional context on views created here, (as modified context inherited from the parent, and to be inherited by child views)\n\t\t\t// Note: If no jQuery, $extend does not support chained copies - so limit extend() to two parameters\n\t\t\t// TODO could make this a reusable helper for merging context.\n\t\t\thasContext = (context && context !== parentContext);\n\t\t\tif (dynCtx || hasContext) {\n\t\t\t\tparentContext = $extend({}, parentContext);\n\t\t\t\tif (hasContext) {\n\t\t\t\t\t$extend(parentContext, context);\n\t\t\t\t}\n\t\t\t\tif (dynCtx) {\n\t\t\t\t\t$extend(parentContext, dynCtx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontext = parentContext;\n\n\t\t\tif (!tmpl.fn) {\n\t\t\t\ttmpl = $templates[tmpl] || $templates(tmpl);\n\t\t\t}\n\n\t\t\tif (tmpl) {\n\t\t\t\tonRender = context.link !== FALSE && onRender; // If link===false, do not call onRender, so no data-linking annotations\n\t\t\t\tif ($.isArray(data) && !isLayout) {\n\t\t\t\t\t// Create a view for the array, whose child views correspond to each data item.\n\t\t\t\t\t// (Note: if key and parentView are passed in along with parent view, treat as\n\t\t\t\t\t// insert -e.g. from view.addViews - so parentView is already the view item for array)\n\t\t\t\t\tnewView = swapContent ? parentView : (key !== undefined && parentView) || View(context, path, parentView, data, tmpl, key, onRender, TRUE);\n\t\t\t\t\tfor (i = 0, l = data.length; i < l; i++) {\n\t\t\t\t\t\t// Create a view for each data item.\n\t\t\t\t\t\tdataItem = data[i];\n\t\t\t\t\t\titemResult = tmpl.fn(dataItem, View(context, path, newView, dataItem, tmpl, (key || 0) + i, onRender), $views);\n\t\t\t\t\t\tresult += onRender ? onRender(itemResult, tmpl, props) : itemResult;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Create a view for singleton data object.\n\t\t\t\t\tnewView = swapContent ? parentView : View(context, path, parentView, data, tmpl, key, onRender);\n\t\t\t\t\tnewView._onRender = onRender;\n\t\t\t\t\tresult += tmpl.fn(data, newView, $views, returnVal);\n\t\t\t\t}\n\t\t\t\treturn onRender ? onRender(result, tmpl, props, newView.key, path) : result;\n\t\t\t}\n\t\t}\n\t\terror(\"No template found\");\n\t\treturn \"\";\n\t}\n\n\tfunction returnVal(value) {\n\t\treturn value;\n\t}\n\n\t//===========================\n\t// Build and compile template\n\t//===========================\n\n\t// Generate a reusable function that will serve to render a template against data\n\t// (Compile AST then build template function)\n\n\tfunction error(message) {\n\t\tif ($views.debugMode) {\n\t\t\tthrow new $views.Error(message);\n\t\t}\n\t}\n\n\tfunction syntaxError(message) {\n\t\terror(\"Syntax error\\n\" + message);\n\t}\n\n\tfunction tmplFn(markup, tmpl, bind) {\n\t\t// Compile markup to AST (abtract syntax tree) then build the template function code from the AST nodes\n\t\t// Used for compiling templates, and also by JsViews to build functions for data link expressions\n\n\t\tvar newNode,\n\t\t\t//result,\n\t\t\tallowCode = tmpl && tmpl.allowCode,\n\t\t\tastTop = [],\n\t\t\tloc = 0,\n\t\t\tstack = [],\n\t\t\tcontent = astTop,\n\t\t\tcurrent = [, , , astTop];\n\n\t\t//==== nested functions ====\n\t\tfunction pushPreceedingContent(shift) {\n\t\t\tshift -= loc;\n\t\t\tif (shift) {\n\t\t\t\tcontent.push(markup.substr(loc, shift).replace(rNewLine, \"\\\\n\"));\n\t\t\t}\n\t\t}\n\n\t\tfunction blockTagCheck(tagName) {\n\t\t\ttagName && syntaxError('Unmatched or missing tag: \"{{/' + tagName + '}}\" in template:\\n' + markup);\n\t\t}\n\n\t\tfunction parseTag(all, defer, tagName, converter, colon, html, code, params, slash, closeBlock, index) {\n\t\t\t//                  tag           converter colon  html  code     params         slash   closeBlock\n\t\t\t//      /{{(?:(?:(\\w+(?=[\\/!\\s\\}!]))|(?:(\\w+)?(:)|(?:(>)|(\\*)))((?:[^\\}]|}(?!}))*?)(\\/)?|(?:\\/(\\w+)))}}/g;\n\t\t\t// Build abstract syntax tree (AST): [ tagName, converter, params, content, hash, contentMarkup, link ]\n\t\t\tif (html) {\n\t\t\t\tcolon = \":\";\n\t\t\t\tconverter = \"html\";\n\t\t\t}\n\t\t\tvar current0,\n\t\t\t\thash = \"\",\n\t\t\t\tpassedCtx = \"\",\n\t\t\t\t// Block tag if not self-closing and not {{:}} or {{>}} (special case) and not a data-link expression (has bind parameter)\n\t\t\t\tblock = !slash && !colon && !bind;\n\n\t\t\t//==== nested helper function ====\n\n\t\t\ttagName = tagName || colon;\n\t\t\tpushPreceedingContent(index);\n\t\t\tloc = index + all.length; // location marker - parsed up to here\n\t\t\tif (code) {\n\t\t\t\tif (allowCode) {\n\t\t\t\t\tcontent.push([\"*\", params.replace(rUnescapeQuotes, \"$1\")]);\n\t\t\t\t}\n\t\t\t} else if (tagName) {\n\t\t\t\tif (tagName === \"else\") {\n\t\t\t\t\tcurrent[5] = markup.substring(current[5], index); // contentMarkup for block tag\n\t\t\t\t\tcurrent = stack.pop();\n\t\t\t\t\tcontent = current[3];\n\t\t\t\t\tblock = TRUE;\n\t\t\t\t} else if (defer) {\n\t\t\t\t\tstack.push(current);\n\t\t\t\t\tcurrent = [\"!\", , , [], ,index];\n\t\t\t\t\tcontent.push(current);\n\t\t\t\t\tcontent = current[3];\n\t\t\t\t}\n\t\t\t\tparams = (params\n\t\t\t\t\t? parseParams(params, bind, defer)\n\t\t\t\t\t\t.replace(rBuildHash, function(all, isCtx, keyValue) {\n\t\t\t\t\t\t\tif (isCtx) {\n\t\t\t\t\t\t\t\tpassedCtx += keyValue + \",\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\thash += keyValue + \",\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t})\n\t\t\t\t\t: \"\");\n\t\t\t\thash = hash.slice(0, -1);\n\t\t\t\tparams = params.slice(0, -1);\n\t\t\t\tnewNode = [\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tconverter || \"\",\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\tblock && [],\n\t\t\t\t\t\t\"{\" + (hash ? (\"props:{\" + hash + \"},\") : \"\") + \"data: data\" + (passedCtx ? \",ctx:{\" + passedCtx.slice(0, -1) + \"}\" : \"\") + \"}\"\n\t\t\t\t\t];\n\t\t\t\tcontent.push(newNode);\n\t\t\t\tif (block) {\n\t\t\t\t\tstack.push(current);\n\t\t\t\t\tcurrent = newNode;\n\t\t\t\t\tcurrent[5] = loc; // Store current location of open tag, to be able to add contentMarkup when we reach closing tag\n\t\t\t\t} else if (defer) {\n\t\t\t\t\tcurrent[5] = markup.substring(current[5], loc); // contentMarkup for block tag\n\t\t\t\t\tcurrent = stack.pop();\n\t\t\t\t}\n\t\t\t} else if (closeBlock) {\n\t\t\t\tcurrent0 = current[0];\n\t\t\t\tblockTagCheck(closeBlock !== current0 && !(closeBlock === \"if\" && current0 === \"else\") && current0);\n\t\t\t\tcurrent[5] = markup.substring(current[5], index); // contentMarkup for block tag\n\t\t\t\tif (current0 === \"!\") {\n\t\t\t\t\t// defer\n\t\t\t\t\tcurrent[5] = markup.substring(current[5], loc); // contentMarkup for block tag\n\t\t\t\t\tcurrent = stack.pop();\n\t\t\t\t}\n\t\t\t\tcurrent = stack.pop();\n\t\t\t}\n\t\t\tblockTagCheck(!current && closeBlock);\n\t\t\tcontent = current[3];\n\t\t}\n\t\t//==== /end of nested functions ====\n\n//\t\tresult = compiledTmplsCache[markup];  // Only cache if template is not named and markup length < ... Consider standard optimization for data-link=\"a.b.c\"\n//\t\tif (!result) {\n//\t\t\tresult = markup;\n\t\t\tmarkup = markup.replace(rEscapeQuotes, \"\\\\$1\");\n\t\t\tblockTagCheck(stack[0] && stack[0][3].pop()[0]);\n\n\t\t\t// Build the AST (abstract syntax tree) under astTop\n\t\t\tmarkup.replace(rTag, parseTag);\n\n\t\t\tpushPreceedingContent(markup.length);\n\n//\t\t\tresult = compiledTmplsCache[result] = buildCode(astTop, tmpl);\n//\t\t}\n//\t\treturn result;\n\t\treturn  buildCode(astTop, tmpl);\n\t}\n\n\tfunction buildCode(ast, tmpl) {\n\t\t// Build the template function code from the AST nodes, and set as property on the passed in template object\n\t\t// Used for compiling templates, and also by JsViews to build functions for data link expressions\n\t\tvar node, i, l, code, hasTag, hasEncoder, getsValue, hasConverter, hasViewPath, tag, converter, params, hash, nestedTmpl, allowCode, content, attr, quot,\n\t\t\ttmplOptions = tmpl ? {\n\t\t\t\tallowCode: allowCode = tmpl.allowCode,\n\t\t\t\tdebug: tmpl.debug\n\t\t\t} : {},\n\t\t\tnested = tmpl && tmpl.tmpls;\n\n\t\t// Use the AST (ast) to build the template function\n\t\tl = ast.length;\n\t\tcode = (l ? \"\" : '\"\";');\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\t// AST nodes: [ tagName, converter, params, content, hash, contentMarkup, link ]\n\t\t\tnode = ast[i];\n\t\t\tif (\"\" + node === node) { // type string\n\t\t\t\tcode += '\"' + node + '\"+';\n\t\t\t} else {\n\t\t\t\ttag = node[0];\n\t\t\t\tif (tag === \"*\") {\n\t\t\t\t\tcode = code.slice(0, i ? -1 : -3) + \";\" + node[1] + (i + 1 < l ? \"ret+=\" : \"\");\n\t\t\t\t} else {\n\t\t\t\t\tconverter = node[1];\n\t\t\t\t\tparams = node[2];\n\t\t\t\t\tcontent = node[3];\n\t\t\t\t\thash = node[4];\n\t\t\t\t\tmarkup = node[5];\n\t\t\t\t\tif (tag.slice(-1) === \"!\") {\n\t\t\t\t\t\t// Create template object for nested template\n\t\t\t\t\t\tnestedTmpl = TmplObject(markup, tmplOptions, tmpl, nested.length);\n\t\t\t\t\t\t// Compile to AST and then to compiled function\n\t\t\t\t\t\tbuildCode(content, nestedTmpl);\n\t\t\t\t\t\tif (attr = /\\s+[\\w-]*\\s*\\=\\s*\\\\['\"]$/.exec(ast[i-1])) {\n\t\t\t\t\t\t\terror(\"'{{!' in attribute:\\n...\" + ast[i-1] + \"{{!...\\nUse data-link\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcode += 'view.renderLink(' + nested.length + ')+';\n\t\t\t\t\t\tnestedTmpl.bound = TRUE;\n\t\t\t\t\t\tnestedTmpl.fn.attr = attr || \"leaf\";\n\t\t\t\t\t\tnested.push(nestedTmpl);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (content) {\n\t\t\t\t\t\t\t// Create template object for nested template\n\t\t\t\t\t\t\tnestedTmpl = TmplObject(markup, tmplOptions, tmpl, nested.length);\n\t\t\t\t\t\t\t// Compile to AST and then to compiled function\n\t\t\t\t\t\t\tbuildCode(content, nestedTmpl);\n\t\t\t\t\t\t\tnested.push(nestedTmpl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thasViewPath = hasViewPath || hash.indexOf(\"view\") > -1;\n\t\t\t\t\t\tcode += (tag === \":\"\n\t\t\t\t\t\t? (converter === \"html\"\n\t\t\t\t\t\t\t? (hasEncoder = TRUE, \"h(\" + params)\n\t\t\t\t\t\t\t: converter\n\t\t\t\t\t\t\t\t? (hasConverter = TRUE, 'c(\"' + converter + '\",view,this,' + params)\n\t\t\t\t\t\t\t\t: (getsValue = TRUE, \"((v=\" + params + ')!=u?v:\"\"')\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: (hasTag = TRUE, 't(\"' + tag + '\",view,this,'\n\t\t\t\t\t\t\t+ (content ? nested.length : '\"\"') // For block tags, pass in the key (nested.length) to the nested content template\n\t\t\t\t\t\t\t+ \",\" + hash + (params ? \",\" : \"\") + params))\n\t\t\t\t\t\t\t+ \")+\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcode = fnDeclStr\n\t\t+ (getsValue ? \"v,\" : \"\")\n\t\t+ (hasTag ? \"t=j._tag,\" : \"\")\n\t\t+ (hasConverter ? \"c=j._convert,\" : \"\")\n\t\t+ (hasEncoder ? \"h=j.converters.html,\" : \"\")\n\t\t+ \"ret; try{\\n\\n\"\n\t\t+ (tmplOptions.debug ? \"debugger;\" : \"\")\n\t\t+ (allowCode ? 'ret=' : 'return ')\n\t\t+ code.slice(0, -1) + \";\\n\\n\"\n\t\t+ (allowCode ? \"return ret;\" : \"\")\n\t\t+ \"}catch(e){return j._err(e);}\";\n\n\t\ttry {\n\t\t\tcode = new Function(\"data, view, j, b, u\", code);\n\t\t} catch (e) {\n\t\t\tsyntaxError(\"Compiled template code:\\n\\n\" + code, e);\n\t\t}\n\n\t\t// Include only the var references that are needed in the code\n\t\tif (tmpl) {\n\t\t\ttmpl.fn = code;\n\t\t}\n\t\treturn code;\n\t}\n\n\tfunction parseParams(params, bind, defer) {\n\t\tvar named,\n\t\t\tfnCall = {},\n\t\t\tparenDepth = 0,\n\t\t\tquoted = FALSE, // boolean for string content in double quotes\n\t\t\taposed = FALSE; // or in single quotes\n\n\t\tfunction parseTokens(all, lftPrn0, lftPrn, path, operator, err, eq, path2, prn, comma, lftPrn2, apos, quot, rtPrn, prn2, space) {\n\t\t\t// rParams = /(?:([([])\\s*)?(?:([#~]?[\\w$.]+)?\\s*((\\+\\+|--)|\\+|-|&&|\\|\\||===|!==|==|!=|<=|>=|[<>%*!:?\\/]|(=))\\s*|([#~]?[\\w$.^]+)([([])?)|(,\\s*)|(\\(?)\\\\?(?:(')|(\"))|(?:\\s*([)\\]])([([]?))|(\\s+)/g,\n\t\t\t//            lftPrn                  path    operator err                                                eq         path2       prn    comma   lftPrn3   apos quot        rtPrn   prn2   space\n\t\t\t// (left paren? followed by (path? followed by operator) or (path followed by paren?)) or comma or apos or quot or right paren or space\n\t\t\toperator = operator || \"\";\n\t\t\tlftPrn = lftPrn || lftPrn0 || lftPrn2;\n\t\t\tpath = path || path2;\n\t\t\tprn = prn || prn2 || \"\";\n\t\t\toperator = operator || \"\";\n\t\t\tvar bindParam = (bind || defer) && prn !== \"(\";\n\n\t\t\tfunction parsePath(all, object, helper, view, viewProperty, pathTokens, leafToken) {\n\t\t\t\t// rPath = /^(?:null|true|false|\\d[\\d.]*|([\\w$]+|~([\\w$]+)|#(view|([\\w$]+))?)([\\w$.]*?)(?:[.[]([\\w$]+)\\]?)?|(['\"]).*\\8)$/g,\n\t\t\t\t//                                        object   helper    view  viewProperty pathTokens   leafToken     string\n\t\t\t\tif (object) {\n\t\t\t\t\tvar leaf,\n\t\t\t\t\t\tret = (helper\n\t\t\t\t\t\t\t? 'view._hlp(\"' + helper + '\")'\n\t\t\t\t\t\t\t: view\n\t\t\t\t\t\t\t\t? \"view\"\n\t\t\t\t\t\t\t\t: \"data\")\n\t\t\t\t\t\t+ (leafToken\n\t\t\t\t\t\t\t? (viewProperty\n\t\t\t\t\t\t\t\t? \".\" + viewProperty\n\t\t\t\t\t\t\t\t: helper\n\t\t\t\t\t\t\t\t\t? \"\"\n\t\t\t\t\t\t\t\t\t: (view ? \"\" : \".\" + object)\n\t\t\t\t\t\t\t\t) + (pathTokens || \"\")\n\t\t\t\t\t\t\t: (leafToken = helper ? \"\" : view ? viewProperty || \"\" : object, \"\"));\n\n\t\t\t\t\tleaf = (leafToken ? \".\" + leafToken : \"\");\n\t\t\t\t\tif (!bindParam) {\n\t\t\t\t\t\tret = ret + leaf;\n\t\t\t\t\t}\n\t\t\t\t\tret = ret.slice(0, 9) === \"view.data\"\n\t\t\t\t\t? ret.slice(5) // convert #view.data... to data...\n\t\t\t\t\t: ret;\n\t\t\t\t\tif (bindParam) {\n\t\t\t\t\t\tret = \"b(\" + ret + ',\"' + leafToken + '\")' + leaf;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\treturn all;\n\t\t\t}\n\n\t\t\tif (err) {\n\t\t\t\tsyntaxError(params);\n\t\t\t} else {\n\t\t\t\treturn (aposed\n\t\t\t\t// within single-quoted string\n\t\t\t\t? (aposed = !apos, (aposed ? all : '\"'))\n\t\t\t\t: quoted\n\t\t\t\t// within double-quoted string\n\t\t\t\t\t? (quoted = !quot, (quoted ? all : '\"'))\n\t\t\t\t\t:\n\t\t\t\t(\n\t\t\t\t\t(lftPrn\n\t\t\t\t\t\t\t? (parenDepth++, lftPrn)\n\t\t\t\t\t\t\t: \"\")\n\t\t\t\t\t+ (space\n\t\t\t\t\t\t? (parenDepth\n\t\t\t\t\t\t\t? \"\"\n\t\t\t\t\t\t\t: named\n\t\t\t\t\t\t\t\t? (named = FALSE, \"\\b\")\n\t\t\t\t\t\t\t\t: \",\"\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: eq\n\t\t\t\t// named param\n\t\t\t\t\t\t\t? (parenDepth && syntaxError(params), named = TRUE, '\\b' + path + ':')\n\t\t\t\t\t\t\t: path\n\t\t\t\t// path\n\t\t\t\t\t\t\t\t? (path.replace(rPath, parsePath)\n\t\t\t\t\t\t\t\t\t+ (prn\n\t\t\t\t\t\t\t\t\t\t? (fnCall[++parenDepth] = TRUE, prn)\n\t\t\t\t\t\t\t\t\t\t: operator)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t: operator\n\t\t\t\t\t\t\t\t\t? operator\n\t\t\t\t\t\t\t\t\t: rtPrn\n\t\t\t\t// function\n\t\t\t\t\t\t\t\t\t\t? ((fnCall[parenDepth--] = FALSE, rtPrn)\n\t\t\t\t\t\t\t\t\t\t\t+ (prn\n\t\t\t\t\t\t\t\t\t\t\t\t? (fnCall[++parenDepth] = TRUE, prn)\n\t\t\t\t\t\t\t\t\t\t\t\t: \"\")\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t: comma\n\t\t\t\t\t\t\t\t\t\t\t? (fnCall[parenDepth] || syntaxError(params), \",\") // We don't allow top-level literal arrays or objects\n\t\t\t\t\t\t\t\t\t\t\t: lftPrn0\n\t\t\t\t\t\t\t\t\t\t\t\t? \"\"\n\t\t\t\t\t\t\t\t\t\t\t\t: (aposed = apos, quoted = quot, '\"')\n\t\t\t\t))\n\t\t\t);\n\t\t\t}\n\t\t}\n\t\tparams = (params + \" \").replace(rParams, parseTokens);\n\t\treturn params;\n\t}\n\n\tfunction compileNested(items, process, options) {\n\t\tvar key, nestedItem;\n\t\tif (items) {\n\t\t\tfor (key in items) {\n\t\t\t\t// compile nested template declarations\n\t\t\t\tnestedItem = items[key];\n\t\t\t\tif (!nestedItem.is) {\n\t\t\t\t\t// Not yet compiled\n\t\t\t\t\titems[key] = process(nestedItem, key, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction compile(tmpl, name, parent, options) {\n\t\t// tmpl is either a template object, a selector for a template script block, the name of a compiled template, or a template object\n\t\t// options is the set of template properties, c\n\t\tvar tmplOrMarkup, elem;\n\n\t\t//==== nested functions ====\n\t\tfunction tmplOrMarkupFromStr(value) {\n\t\t\t// If value is of type string - treat as selector, or name of compiled template\n\t\t\t// Return the template object, if already compiled, or the markup string\n\n\t\t\tif ((\"\" + value === value) || value.nodeType > 0) {\n\t\t\t\ttry {\n\t\t\t\t\telem = value.nodeType > 0\n\t\t\t\t\t? value\n\t\t\t\t\t: !rTmplString.test(value)\n\t\t\t\t\t// If value is a string and does not contain HTML or tag content, then test as selector\n\t\t\t\t\t\t&& jQuery && jQuery(value)[0];\n\t\t\t\t\t// If selector is valid and returns at least one element, get first element\n\t\t\t\t\t// If invalid, jQuery will throw. We will stay with the original string.\n\t\t\t\t} catch (e) { }\n\n\t\t\t\tif (elem) {\n\t\t\t\t\t// Generally this is a script element.\n\t\t\t\t\t// However we allow it to be any element, so you can for example take the content of a div,\n\t\t\t\t\t// use it as a template, and replace it by the same content rendered against data.\n\t\t\t\t\t// e.g. for linking the content of a div to a container, and using the initial content as template:\n\t\t\t\t\t// $.link(\"#content\", model, {tmpl: \"#content\"});\n\n\t\t\t\t\t// Create a name for compiled template if none provided\n\t\t\t\t\tvalue = $templates[elem.getAttribute(tmplAttr)];\n\t\t\t\t\tif (!value) {\n\t\t\t\t\t\t// Not already compiled and cached, so compile and cache the name\n\t\t\t\t\t\tname = name || \"_\" + autoTmplName++;\n\t\t\t\t\t\telem.setAttribute(tmplAttr, name);\n\t\t\t\t\t\tvalue = compile(elem.innerHTML, name, parent, options); // Use tmpl as options\n\t\t\t\t\t\t$templates[name] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t// If value is not a string, return undefined\n\t\t}\n\n\t\t//==== Compile the template ====\n\t\ttmpl = tmpl || \"\";\n\t\ttmplOrMarkup = tmplOrMarkupFromStr(tmpl);\n\n\t\t// If tmpl is a template object, use it for options\n\t\toptions = options || (tmpl.markup ? tmpl : {});\n\t\toptions.name = name;\n\t\toptions.is = \"tmpl\";\n\n\t\t// If tmpl is not a markup string or a selector string, then it must be a template object\n\t\t// In that case, get it from the markup property of the object\n\t\tif (!tmplOrMarkup && tmpl.markup && (tmplOrMarkup = tmplOrMarkupFromStr(tmpl.markup))) {\n\t\t\tif (tmplOrMarkup.fn && (tmplOrMarkup.debug !== tmpl.debug || tmplOrMarkup.allowCode !== tmpl.allowCode)) {\n\t\t\t\t// if the string references a compiled template object, but the debug or allowCode props are different, need to recompile\n\t\t\t\ttmplOrMarkup = tmplOrMarkup.markup;\n\t\t\t}\n\t\t}\n\t\tif (tmplOrMarkup !== undefined) {\n\t\t\tif (name && !parent) {\n\t\t\t\t$render[name] = function() {\n\t\t\t\t\treturn tmpl.render.apply(tmpl, arguments);\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (tmplOrMarkup.fn || tmpl.fn) {\n\t\t\t\t// tmpl is already compiled, so use it, or if different name is provided, clone it\n\t\t\t\tif (tmplOrMarkup.fn) {\n\t\t\t\t\tif (name && name !== tmplOrMarkup.name) {\n\t\t\t\t\t\ttmpl = $extend($extend({}, tmplOrMarkup), options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmpl = tmplOrMarkup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// tmplOrMarkup is a markup string, not a compiled template\n\t\t\t\t// Create template object\n\t\t\t\ttmpl = TmplObject(tmplOrMarkup, options, parent, 0);\n\t\t\t\t// Compile to AST and then to compiled function\n\t\t\t\ttmplFn(tmplOrMarkup, tmpl);\n\t\t\t}\n\t\t\tcompileNested(options.templates, compile, tmpl);\n\t\t\tcompileNested(options.tags, compileTag);\n\t\t\treturn tmpl;\n\t\t}\n\t}\n\t//==== /end of function compile ====\n\n\tfunction TmplObject(markup, options, parent, key) {\n\t\t// Template object constructor\n\n\t\t// nested helper function\n\t\tfunction extendStore(storeName) {\n\t\t\tif (parent[storeName]) {\n\t\t\t\t// Include parent items except if overridden by item of same name in options\n\t\t\t\ttmpl[storeName] = $extend($extend({}, parent[storeName]), options[storeName]);\n\t\t\t}\n\t\t}\n\n\t\toptions = options || {};\n\t\tvar tmpl = {\n\t\t\tmarkup: markup,\n\t\t\ttmpls: [],\n\t\t\tlinks: [],\n\t\t\trender: renderContent\n\t\t};\n\n\t\tif (parent) {\n\t\t\tif (parent.templates) {\n\t\t\t\ttmpl.templates = $extend($extend({}, parent.templates), options.templates);\n\t\t\t}\n\t\t\ttmpl.parent = parent;\n\t\t\ttmpl.name = parent.name + \"[\" + key + \"]\";\n\t\t\ttmpl.key = key;\n\t\t}\n\n\t\t$extend(tmpl, options);\n\t\tif (parent) {\n\t\t\textendStore(\"templates\");\n\t\t\textendStore(\"tags\");\n\t\t\textendStore(\"helpers\");\n\t\t\textendStore(\"converters\");\n\t\t}\n\t\treturn tmpl;\n\t}\n\n\t//========================== Initialize ==========================\n\n\tif (jQuery) {\n\t\t////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// jQuery is loaded, so make $ the jQuery object\n\t\t$ = jQuery;\n\t\t$.templates = $templates;\n\t\t$.render = $render;\n\t\t$.views = $views;\n\t\t$.fn.render = renderContent;\n\n\t} else {\n\t\t////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// jQuery is not loaded.\n\n\t\t$ = global.jsviews = $views;\n\t\t$.extend = function(target, source) {\n\t\t\tvar name;\n\t\t\ttarget = target || {};\n\t\t\tfor (name in source) {\n\t\t\t\ttarget[name] = source[name];\n\t\t\t}\n\t\t\treturn target;\n\t\t};\n\n\t\t$.isArray = Array && Array.isArray || function(obj) {\n\t\t\treturn Object.prototype.toString.call(obj) === \"[object Array]\";\n\t\t};\n\t}\n\n\t$extend = $.extend;\n\n\tfunction replacerForHtml(ch) {\n\t\t// Original code from Mike Samuel <msamuel@google.com>\n\t\treturn escapeMapForHtml[ch]\n\t\t\t// Intentional assignment that caches the result of encoding ch.\n\t\t\t|| (escapeMapForHtml[ch] = \"&#\" + ch.charCodeAt(0) + \";\");\n\t}\n\n\t//========================== Register tags ==========================\n\n\t$viewsTags({\n\t\t\"if\": function() {\n\t\t\tvar ifTag = this,\n\t\t\t\tview = ifTag.view;\n\n\t\t\tview.onElse = function(tagInstance, args) {\n\t\t\t\tvar i = 0,\n\t\t\t\t\tl = args.length;\n\n\t\t\t\twhile (l && !args[i++]) {\n\t\t\t\t\t// Only render content if args.length === 0 (i.e. this is an else with no condition) or if a condition argument is truey\n\t\t\t\t\tif (i === l) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tview.onElse = undefined; // If condition satisfied, so won't run 'else'.\n\t\t\t\ttagInstance.path = \"\";\n\t\t\t\treturn tagInstance.renderContent(view);\n\t\t\t\t// Test is satisfied, so render content, while remaining in current data context\n\t\t\t\t// By passing the view, we inherit data context from the parent view, and the content is treated as a layout template\n\t\t\t\t// (so if the data is an array, it will not iterate over the data\n\t\t\t};\n\t\t\treturn view.onElse(this, arguments);\n\t\t},\n\t\t\"else\": function() {\n\t\t\tvar view = this.view;\n\t\t\treturn view.onElse ? view.onElse(this, arguments) : \"\";\n\t\t},\n\t\t\"for\": function() {\n\t\t\tvar i,\n\t\t\t\tself = this,\n\t\t\t\tresult = \"\",\n\t\t\t\targs = arguments,\n\t\t\t\tl = args.length;\n\n\t\t\tif (l === 0) {\n\t\t\t\t// If no parameters, render once, with #data undefined\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tresult += self.renderContent(args[i]);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t\"*\": function(value) {\n\t\t\treturn value;\n\t\t}\n\t});\n\n\t//========================== Register global helpers ==========================\n\n\t//\t$viewsHelpers({ // Global helper functions\n\t//\t\t// TODO add any useful built-in helper functions\n\t//\t});\n\n\t//========================== Register converters ==========================\n\n\t$viewsConverters({\n\t\thtml: function(text) {\n\t\t\t// HTML encoding helper: Replace < > & and ' and \" by corresponding entities.\n\t\t\t// inspired by Mike Samuel <msamuel@google.com>\n\t\t\treturn text != undefined ? String(text).replace(htmlSpecialChar, replacerForHtml) : \"\";\n\t\t}\n\t});\n\n\t//========================== Define default delimiters ==========================\n\t$viewsDelimiters();\n\n})(this, this.jQuery);\nWindow size: x \nViewport size: x"]],"start1":0,"start2":0,"length1":0,"length2":36973}]],"length":36973}
{"contributors":[],"silentsave":false,"ts":1359668912265,"patch":[[{"diffs":[[0,"ry);"],[-1,"\nWindow size: x \nViewport size: x"]],"start1":36936,"start2":36936,"length1":37,"length2":4}]],"length":36940,"saved":false}
